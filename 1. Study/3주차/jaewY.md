## 연산자
     - 표현식 : 결과적으로 어떤 값으로 평가되는 것
     - 평가란? 식의 값을 계산하는 것
     - 가장 간단한 표현식 : 원시 값(숫자, 문자열, 논리값 등)

     - 연산자를 사용하면 표현식을 조합하여 더욱 복잡한 표현식을 만들어 낼 수 있음
     
     
 ![image](https://user-images.githubusercontent.com/89966610/138391669-3a44fad2-8bf9-4202-8a78-882ac64f0e5a.png)
 
     - 피연산자 개수에 따라 단항 연산자, 이항 연산자, 삼항 연산자(only ?:)로 분류
     - 표현식은 먼저 왼쪽 피연사자 값부터 순서대로 평가되고, 그 다음에 연산자로 계산이 시작됨
        * 예외 :   ,&&, ?:  → 먼저 평가된 다음에 피연산자 값을 평가
        
        
### 연산자의 우선순위 
    - 그룹 연산자 ()
    - 연산자에는 '우선순위'가 정해져 있음 ( 130쪽 표 5-1 참고)
  ```javascript
      2 + 3 * 4

      2 + (3 * 4)  // 14
     (2 + 3) * 4  // 20
  ```
### 연산자 결합 법칙
    - 연산자 우선순위에 따라 진행되지만, 우선순위가 같은 연산자가 나열되어 있으면 연산 순서를 연산자 우선순위만으로는 결정할 수 없음 
    - 연산자의 우선순위가 같을 때 : 왼쪽에서 오른쪽 방향으로 결합
   ```javascript 
     24 / 6 * 2   // ???
    (24 / 6) * 2  // 8
   ```
   
### 연산자의 부수 효과 
   - 부수 효과가 있는 표현식 : 변수 값을 바꾸는 표현식
   - 부수 효과가 있는 연산자 : 대입 연산자, 증가 연산자, 감소 연산자, delete 
   ```javascript
    표현식1  x + y
    표현식2  x = y  
   ```
    
    
## 산술 연산
     - 산술 연산자 : 피연산자가 숫자인 연산자 ( if not? → 연산자가 피연산자 타입을 숫자 타입으로 바꾸어 연산)
     - NaN : 피연산자가 숫자로 바꿀 수 없는 값이거나 계산할 수 없을 때
     - 모든 산술 연산은 64비트 부동소수점 연산으로 이루어짐
     
 
 ### 산술 이항 연산자   
        +, -, *, /(나누기), %(나머지)
1) 정수끼리 나누어도 결과가 부동소수점이 된다
     * 다른 프로그래밍 언어에서는 정수 / 정수의 결괏값이 정수
     ```javascript
     7 / 2  // 3.5
     ```
3) 나머지 연산자 %의 피연산자는 부동소수점이다
     * 일부 프로그래밍 언어에서는 정수의 나머지 값만 나머지 연산자 %로 구할 수 있다
     * 즉 부동소수점 a와 부동소수점 b의 부동소수점을 구할 수 있다
     ```javascript
     15 % 4  // 3
     5 % 1.5  // 0.5
     ```
5)  +연산자는 피연산자 중 하나가 문자열이면 나머지 피연산자를 문자열로 만든다
     * +연산자는 피연산자가 숫자면 더하고 문자열잉면 연결
     ```javascript
     1 + "2month"  // "12month"
7) 기타
     * NaN : 계산할 수 없는 경우
     * 산술 연산자의 피연산자가 true면 1, 
        false와 null이면 0,
        undefined면 NaN으로 평가
     ```javascript
     0/0  // NaN:계산할 수 없음
     "one" * 1  // NaN
     true + true  // 2
     
 ### 산술 단항 연산자
     ++(증가 연산자)
     ++a : a에 1을 더한 다음 a 값 평가
     a++ : a를 평가한 다음에 a에 1을 더함
     
     --(감소 연산자)
     --a : a에서 1을 뺀 다음에 a 값 평가
     a-- : a를 평가한 다음에 a에서 1을 뺌
     
     +(아무것도 처리하지 않음)
     +a : a와 같은 값으로 평가
     
     -(부호 반전)
     -a : a의 부호를 반전한 값으로 평가
     
 * 후위 표기법 : 피연산자 값을 평가한 다음에 피연산자 값을 바꿈 

### 산술 대입 연산자
     - 산술 이항 연산자를 조합한 연산을 좀 더 간략하게 표기한 것
     
    a += b : a = a + b 
    a -= b : a = a - b
    a *= b : a =  a * b
    a /= b : a = a / b
    a %= b : a = a % b
    
### Math 객체의 프로퍼티
     - js는 수학 연산과 연동되어 있음 !!
     - sin → Math.sin 메서드
       cos → Math.cos 메서드
       원주율 → Math.PI 프로퍼티
     
```javascript
function polarToDescartes(r,theta)  {
   var angle = Math.PI * theta / 180;
   return {x: r*Math.cos(angle), y: r*Math.sin(angle)};
} 
```

* 책 p136~137 표 5-5, 5-6 참고

### 부동소수점과 정확도 문제
     - (산술 연산 시) 숫자에 유효한 자릿수가 있으므로 계산할 때 오차가 발생!!! 
     - js의 숫자는 IEEE754로 규정된 64비트 부동소수점 → 64자릿수의 2진수 부동소수점을 표현
     
 * 고정소수점이란???


 *보통 학교에서 소수에 대해 가장 먼저 배우고 또 가장 많이 사용하는 일반적인 소수 표기는 고정소수점 (fixed-point)
 
  점 (.)을 기준으로 왼쪽에 정수부를 적고, 오른쪽에 소수부를 적는다.
 ![image](https://user-images.githubusercontent.com/89966610/138576570-2524a5f7-479d-4f02-a4cd-511f7fb1ac15.png)
 장점 - 정수가 표현하는 범위를 자릿수만큼 밑으로 내린 것과 같기 때문에 범위 내의 모든 수를 오차 없이 정확하게 표현할 수 있음
      - 정수형과 똑같은 방법으로 계산 가능
 
 단점 - 표현 범위가 매우 작음
      → 본래 10자리에 표현할 수 있던 자료형의 5자리를 떼어 소수부에 나눠준다면, 그 자료형이 표현할 수 있는 수의 범위는 정수부 기준으로 다섯 자리밖에 되지 않는다는 뜻

이러한 단점을 보완하기 위해 널리 쓰이는 자료형이 바로 부동소수점 자료형!

![image](https://user-images.githubusercontent.com/89966610/138594065-244cb85e-e653-4389-a76e-6becdd460607.png)

## 문자열 제어하기
     + 연산자는 피연산자가 모두 문자열이면 문자열로 연결
```javascript
"Hello " + "World!"  // "Hello World!"
"1" + "2"  // "12"
```
     - 피연산자 중 하나가 문자열 또는 문자열로 변환할 수 있는 객체라면 다른 피연산자의 타입을 문자열로 바꾼 다음 연결
```javascript
10 + "little indians"  // "10 little indians"
1 + {}  // "1[object Object]"
```

     -그렇지 않으면 피연산자 두 개를 숫자 또는 NaN으로 타입을 바꾸어 더함
      * js 실행 환경에 따라 처리하는 방법 다름
      
      
### 문자열을 조작하는 메서드
     -String 객체 : 문자열을 처리하기 위한 객체
     -문자열을 String 객체로 변환하려면 String 생성자를 사용

     -원시 값을 객체로 래핑 : 원시 값을 객체로 변환하는 행위
     (*String 객체에는 문자열을 처리하기 위한 다양한 프로퍼티와 메서드가 있음)
     (표 140쪽)
     ex. 문자열의 길이 : 배여로가 마찬가지로 length 프로퍼티로 구할 수 있음
     msgObj.length // 23

     - String 객체로 표시되는 문자열의 각 문자에는 왼쪽부터 순서대로 0부터 시작하는 번호가 매겨져 있음
     - 즉, n번째를 구하세요~ (단, n은 0부터 시작)
     - charAt 메서드를 사용하면 문자열의 n번째 문자를 구할 수 있음
     - 문자열은 객체가 아니므로 프로퍼티를 가지고 있지 않음
     - 엥 그러면 어떻게 동작해?
     - 문자열에서 로퍼티를 사용하려고 하면 무자열이 자동으로 String 객체로 변환되기 떄문
     - ex

```javascript
var c = msg.charAt(3); // 이 아이를 실행시켜보라
var msgObj = new String(msg); // 문자열을 String 객체로 변환 //여기서 msgObj는 래퍼 객체
var c = msgObj.charAt(3); // String 객체의 메서드를 사용
```

     -래퍼 객체 : 실행 순간에 일시적으로 생성되는 객체/ 사용자 눈에 안 보임/ 처리 끝나면 곧바로 메모리에서 삭제됨 
      * js 에서 원시 값을 처리할 때 원시 값을 래퍼 객체로 자동 변환함
       - 문자열 → String 객체 
       - 숫자 → Number 객체
       - 논리값 → Boolean 객체 
      (단, null과 undefined에는 래퍼 객체 없음)

142-143 쪽 String 예시쪽 다시 보세요

### String 생성자의 메서드
     - js의 함수는 객체이며 프로퍼티를 갖고 있음
     - String 생성자 또한 일종의 함수이며 프로퍼티를 갖고 있음 
 

### 문자열을 배열로 읽고 쓰기
     - 문자열을 읽을 때는 charAt 메서드 대신 대괄호 연산자 사용 가능
     Everything is practice.
     msg [3] // "r"
     msg [msg.length-1] // "."
     
     but, 배열처럼 값을 대입해서 수정은 불가
     msg [3] = "R";
     console.log(msg); // Everything is practice.
    
### 써로게이트 페어
     - Surrogate pair는 두개의 쌍으로 이루어진 문자이다. 
     - 보통 자바스크립트는 UTF-16을 사용하는데 UTF-16은 16비트를 한글자로 표현한다.
     - BMP안에 있는 문자의 경우 16비트 코드 하나로 표현이 가능하지만 밖에 있는 문자중 16비트 코드 두개를 이용하여 표현해야 하는 문자가 있다.
     - 이렇게 16비트 코드 두개를 사용하여 문자 하나를 표현한 것을 surrogate pair라고 하며 앞의 것을 high surrogate, 뒤의 것을 low surrogate라 한다. 
     - 써로게이트 페어로 표현하는 문자는 두 개의 배열 요소로 분리
     
## 논리 연산자와 관계 연산자

### 관계 연산자 
      - 두 개의 피연산자를 비교한 결과를 논리값(true/false)으로 변환
      - 제어 구조(if/else 문, while 문, do/while 문, for 문)에서 조건식으로 만들 때 사용
      ==(!=): 값이 같음(다름)
      ===(!==) : 값과 타입이 같음(다름)
      <(>) : 작음(큼)
      <==(>==) : 작거나(크거나) 같음
      
      ```
      null == undefined
      1 == "1"
      "0xff" == 255
      true == 1
      true == "1"
      (new String("a"
 
      1) 동일 연산자 (==) : 좌변과 우변의 피연산자가 같은지 판별
      2) 일치 연산자 (===) : 피연산자를 평가한 후에 타입을 변환하지 않은 상태의 두 값을 엄격하게 비교
              * NaN === NaN // false       → x ! == x를 만족하는 유일한 값
           
### 논리 연산자
     - 관계 연산자를 사용하여 만든 논리식과 결합하여 더욱 복잡한 논리를 정의
      a&&b(논리곱) : a와 b가 true면 true, 그 외에는 false
       a::b (논리합) : a와 b 중 하나라도 true면 true, 모두가 false면 false
        !a(부정) : a가 true면 false, false면 true

## 기타 연산자
[typeof 연산자]
[조건 연산자]
[쉼표 연산자]
[eval 함수] 

## 명시적 타입 변환




부동소수점이란❓ 
https://gsmesie692.tistory.com/94
